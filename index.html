<!doctype html>
<html lang="en" data-theme="mystic-pastel">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sigil Weaver</title>
  <link rel="stylesheet" href="./styles.css" />
</head>
<body>
  <div class="container">
    <!-- Controls -->
    <section class="panel">
      <div class="header">
        <h1>Sigil Weaver</h1>
      </div>

      <div class="controls">
        <div class="group">
          <label for="phrase">Your spell or intention</label>
          <input id="phrase" type="text" placeholder="e.g., UMBRA MEA SCUTA DOMUM" />
        </div>

        <div class="row">
          <label class="checkbox">
            <input id="includeVowels" type="checkbox" />
            Include vowels (A E I O U)
          </label>
          <label class="checkbox">
            <input id="showLabels" type="checkbox" checked />
            Show labels
          </label>
          <label class="checkbox">
            <input id="transparentBg" type="checkbox" />
            Transparent export
          </label>
        </div>

        <div class="group">
          <label for="method">Method</label>
          <select id="method">
            <option value="alphabet">Alphabet circle (A–Z)</option>
            <option value="numbers19">Numbers circle (1–9, Pythagorean mapping)</option>
          </select>
        </div>

        <div class="group">
          <label for="width">Stroke width: <span id="widthVal">3</span> px</label>
          <input id="width" class="range" type="range" min="1" max="12" step="1" value="3" />
        </div>

        <div class="group">
          <label for="size">Canvas size: <span id="sizeVal">640</span> px</label>
          <input id="size" class="range" type="range" min="420" max="1200" step="20" value="640" />
        </div>

        <div class="buttons">
          <button class="primary" id="renderBtn">Render Sigil</button>
          <button class="ghost" id="exportBtn">Export PNG</button>
          <button class="ghost" id="clearBtn" aria-label="Clear input">Clear</button>
        </div>
      </div>

      <div class="footer">
      <span class="badge" id="stepsBadge">Steps: 0</span>
 
       
      </div>
    </section>

    <!-- Canvas -->
    <section class="panel canvas-wrap">
      <div class="canvas-inner">
        <canvas id="sigilCanvas" width="640" height="640" aria-label="Sigil canvas"></canvas>
      </div>
      <div class="footer">
        <span class="badge">Mode: <span id="modeLabel">Alphabet</span></span>
        <span class="badge" id="filteredBadge">Filtered: –</span>
      </div>
    </section>
  </div>

  <script>
    // Fixed single theme (no toggle)
    const root = document.documentElement;

    /* ---------- Elements ---------- */
    const phraseEl = document.getElementById('phrase');
    const includeVowelsEl = document.getElementById('includeVowels');
    const showLabelsEl = document.getElementById('showLabels');
    const transparentBgEl = document.getElementById('transparentBg');
    const methodEl = document.getElementById('method');
    const widthEl = document.getElementById('width');
    const sizeEl = document.getElementById('size');
    const widthValEl = document.getElementById('widthVal');
    const sizeValEl = document.getElementById('sizeVal');
    const stepsBadge = document.getElementById('stepsBadge');
    const filteredBadge = document.getElementById('filteredBadge');
    const modeLabel = document.getElementById('modeLabel');

    const canvas = document.getElementById('sigilCanvas');
    const ctx = canvas.getContext('2d');

    widthEl.addEventListener('input', () => { widthValEl.textContent = widthEl.value; draw(); });
    sizeEl.addEventListener('input', () => {
      sizeValEl.textContent = sizeEl.value;
      setCanvasSize(parseInt(sizeEl.value, 10));
      draw();
    });

    document.getElementById('renderBtn').addEventListener('click', draw);
    document.getElementById('exportBtn').addEventListener('click', exportPNG);
    document.getElementById('clearBtn').addEventListener('click', () => { phraseEl.value = ''; draw(); });
    phraseEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') draw(); });

    [includeVowelsEl, showLabelsEl, transparentBgEl, methodEl].forEach(el => el.addEventListener('change', draw));

    /* ---------- Numerology map (Pythagorean) ---------- */
    const NUM_MAP = {
      1: ['A','J','S'],
      2: ['B','K','T'],
      3: ['C','L','U'],
      4: ['D','M','V'],
      5: ['E','N','W'],
      6: ['F','O','X'],
      7: ['G','P','Y'],
      8: ['H','Q','Z'],
      9: ['I','R']
    };
    const LETTER_TO_NUM = {};
    for (const n of Object.keys(NUM_MAP)) {
      for (const ch of NUM_MAP[n]) LETTER_TO_NUM[ch] = parseInt(n,10);
    }

    /* ---------- Helpers ---------- */
    function setCanvasSize(px) {
      const ratio = Math.ceil(window.devicePixelRatio || 1);
      canvas.style.width = px + 'px';
      canvas.style.height = px + 'px';
      canvas.width = px * ratio;
      canvas.height = px * ratio;
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    }
    setCanvasSize(parseInt(sizeEl.value, 10));

    function preprocess(text, includeVowels) {
      const onlyLetters = text.toUpperCase().replace(/[^A-Z]/g, '');
      // Remove vowels if requested. Y is NEVER considered a vowel here.
      const filtered = includeVowels ? onlyLetters : onlyLetters.replace(/[AEIOU]/g, '');
      // Remove duplicate letters, keep first occurrence
      let out = '';
      for (const ch of filtered) if (!out.includes(ch)) out += ch;
      return out;
    }

    function seqAlphabet(letters) {
      // Map A-Z around the circle (26 points)
      const points = [];
      const center = { x: canvas.clientWidth/2, y: canvas.clientHeight/2 };
      const radius = Math.min(canvas.clientWidth, canvas.clientHeight) * 0.38;

      for (const ch of letters) {
        const idx = ch.charCodeAt(0) - 65; // 0..25
        const angle = (Math.PI * 1.5) + (idx * (2*Math.PI/26)); // start at top, clockwise
        points.push({
          x: center.x + radius * Math.cos(angle),
          y: center.y + radius * Math.sin(angle),
          label: ch
        });
      }
      // 26 label positions
      const labelR = radius * 1.14
      const labels = Array.from({length:26}, (_,i) => {
        const ang = (Math.PI*1.5) + (i*(2*Math.PI/26));
        return {
          x: center.x + labelR * Math.cos(ang),
          y: center.y + labelR * Math.sin(ang),
          label: String.fromCharCode(65+i)
        };
      });
      return { points, labels, center, radius };
    }

function seqNumbers19(letters) {
  const center = { x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 };
  const radius = Math.min(canvas.clientWidth, canvas.clientHeight) * 0.38;

  const labelRadius = radius * 1.12; // labels outside circle

  const labels = [];
  const digitPos = {};
  for (let i = 1; i <= 9; i++) {
    const ang = (Math.PI * 1.5) + ((i - 1) * (2 * Math.PI / 9));
    const xLabel = center.x + labelRadius * Math.cos(ang);
    const yLabel = center.y + labelRadius * Math.sin(ang);
    const xCircle = center.x + radius * Math.cos(ang);
    const yCircle = center.y + radius * Math.sin(ang);

    labels.push({ x: xLabel, y: yLabel, label: String(i) });
    digitPos[i] = { x: xCircle, y: yCircle }; // keep path at circle radius
  }

  let digits = letters.split('').map(ch => LETTER_TO_NUM[ch]).filter(Boolean);
  digits = digits.filter((d,i,arr) => i===0 || d!==arr[i-1]);

  const counts = {};
  for (const d of digits) counts[d] = (counts[d]||0)+1;
  const repeats = new Set(Object.keys(counts).filter(k => counts[k] > 1).map(Number));

  const points = digits.map(d => {
    const ang = (Math.PI*1.5) + ((d-1) * (2*Math.PI/9));
    return {
      x: center.x + radius * Math.cos(ang),
      y: center.y + radius * Math.sin(ang),
      label: String(d)
    };
  });

  return { points, labels, center, radius, repeats, digitPos };
}



    function drawCircleBase(center, radius, showLabels, labels) {
      // Circle ring
      ctx.save();
      ctx.lineWidth = 1.5;
      // Pull color from CSS variable (muted)
      ctx.strokeStyle = getComputedStyle(root).getPropertyValue('--muted').trim() || 'rgba(255,255,255,0.25)';
      ctx.beginPath();
      ctx.arc(center.x, center.y, radius, 0, Math.PI*2);
      ctx.stroke();

      // tick marks
      const tickCount = labels.length;
      for (let i=0;i<tickCount;i++) {
        const ang = (Math.PI*1.5) + (i * (2*Math.PI/tickCount));
        const inner = radius*0.94;
        const outer = radius*1.02;
        ctx.beginPath();
        ctx.moveTo(center.x + inner*Math.cos(ang), center.y + inner*Math.sin(ang));
        ctx.lineTo(center.x + outer*Math.cos(ang), center.y + outer*Math.sin(ang));
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.stroke();
      }

      // labels
      if (showLabels) {
        ctx.fillStyle = getComputedStyle(root).getPropertyValue('--text').trim() || '#e6e7ea';
        ctx.font = '14px ' + getComputedStyle(document.body).fontFamily;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        for (const l of labels) {
          ctx.fillText(l.label, l.x, l.y);
        }
      }
      ctx.restore();
    }

    function drawPath(points, width) {
      if (points.length === 0) return;
      ctx.save();
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.lineWidth = width;
      // gradient stroke from CSS variables
      const grad = ctx.createLinearGradient(0,0,canvas.clientWidth,canvas.clientHeight);
      const cA = getComputedStyle(root).getPropertyValue('--accent').trim();
      const cB = getComputedStyle(root).getPropertyValue('--accent-2').trim();
      grad.addColorStop(0, cA);
      grad.addColorStop(1, cB);
      ctx.strokeStyle = grad;

      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
      ctx.stroke();

      // start / end markers
      const start = points[0];
      const end = points[points.length-1];
      ctx.fillStyle = cA;
      ctx.beginPath(); ctx.arc(start.x, start.y, width*0.9, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = cB;
      ctx.beginPath(); ctx.arc(end.x, end.y, width*0.9, 0, Math.PI*2); ctx.fill();

      ctx.restore();
    }

function draw() {
  const phrase = phraseEl.value || '';
  const includeVowels = includeVowelsEl.checked; // Y is never treated as vowel
  const filtered = preprocess(phrase, includeVowels);
  const method = methodEl.value;

  // UI labels
  modeLabel.textContent = method === 'alphabet' ? 'Alphabet' : '1–9';

  // Canvas clear / background
  const transparent = transparentBgEl.checked;
  if (!transparent) {
    const panel1 = getComputedStyle(root).getPropertyValue('--panel').trim() || '#171a21';
    const panel2 = getComputedStyle(root).getPropertyValue('--panel-2').trim() || '#1e232d';
    const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.clientHeight);
    bgGrad.addColorStop(0, panel1);
    bgGrad.addColorStop(1, panel2);
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);
  } else {
    ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
  }

  // Build sequence (make sure seqNumbers19 returns repeats & digitPos;
  // if not, code below safely no-ops)
  let data = (method === 'alphabet') ? seqAlphabet(filtered) : seqNumbers19(filtered);

  stepsBadge.textContent = 'Steps: ' + ((data.points && data.points.length) || 0);

  // Base circle (grid + labels)
  drawCircleBase(data.center, data.radius, showLabelsEl.checked, data.labels, method);

  // Highlight repeated digits (Number method only, and only if available)
  if (method === 'numbers19' && data.repeats && data.repeats.size && data.digitPos) {
    const ringColor = getComputedStyle(root).getPropertyValue('--accent-2').trim() || '#a78bfa';
    ctx.save();
    ctx.lineWidth = 2.2;
    ctx.strokeStyle = ringColor;
    for (const d of data.repeats) {
      const p = data.digitPos[d];
      if (!p) continue;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(12, parseInt(widthEl.value, 10) * 1.2), 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Path
  drawPath(data.points, parseInt(widthEl.value, 10));

  // Footer badge — DO THIS AFTER data exists
  filteredBadge.textContent = 'Filtered: ' + (filtered || '–');
  if (method === 'numbers19' && data.repeats && data.repeats.size) {
    filteredBadge.textContent += ' | Repeats: ' + [...data.repeats].sort().join(', ');
  }
}



    function exportPNG() {
      draw();
      const link = document.createElement('a');
      link.download = 'sigil.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    // Initial state & demo text
    phraseEl.value = 'UMBRA MEA SCUTA DOMUM';
    draw();
  </script>
</body>
</html>
